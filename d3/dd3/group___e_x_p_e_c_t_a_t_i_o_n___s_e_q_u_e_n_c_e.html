<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mimic++: sequence</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">mimic++<span id="projectnumber">&#160;v7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/dd3/group___e_x_p_e_c_t_a_t_i_o_n___s_e_q_u_e_n_c_e.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sequence<div class="ingroups"><a class="el" href="../../da/dbc/group___e_x_p_e_c_t_a_t_i_o_n.html">expectation</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Sequences enable deterministic ordering between multiple expectations.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for sequence:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d3/dd3/group___e_x_p_e_c_t_a_t_i_o_n___s_e_q_u_e_n_c_e.svg" width="224" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d48/classmimicpp_1_1_basic_scoped_sequence.html">mimicpp::BasicScopedSequence&lt; Strategy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence type that verifies its owned expectations during destruction.  <a href="../../d2/d48/classmimicpp_1_1_basic_scoped_sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d46/classmimicpp_1_1_lazy_sequence.html">mimicpp::LazySequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lazy sequence interface.  <a href="../../db/d46/classmimicpp_1_1_lazy_sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d43/classmimicpp_1_1_greedy_sequence.html">mimicpp::GreedySequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greedy sequence interface.  <a href="../../db/d43/classmimicpp_1_1_greedy_sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf9c4e7108a57906787965591f6064d82" id="r_gaf9c4e7108a57906787965591f6064d82"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf9c4e7108a57906787965591f6064d82">mimicpp::GreedyScopedSequence</a> = <a class="el" href="../../d2/d48/classmimicpp_1_1_basic_scoped_sequence.html">BasicScopedSequence</a>&lt;sequence::detail::GreedyStrategy{}&gt;</td></tr>
<tr class="memdesc:gaf9c4e7108a57906787965591f6064d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scoped-sequence type with greedy strategy.  <br /></td></tr>
<tr class="separator:gaf9c4e7108a57906787965591f6064d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9efea600d953c01de2d99d7d144264e4" id="r_ga9efea600d953c01de2d99d7d144264e4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9efea600d953c01de2d99d7d144264e4">mimicpp::LazyScopedSequence</a> = <a class="el" href="../../d2/d48/classmimicpp_1_1_basic_scoped_sequence.html">BasicScopedSequence</a>&lt;sequence::detail::LazyStrategy{}&gt;</td></tr>
<tr class="memdesc:ga9efea600d953c01de2d99d7d144264e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scoped-sequence type with lazy strategy.  <br /></td></tr>
<tr class="separator:ga9efea600d953c01de2d99d7d144264e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7c9e177bed083aa4c61b13b78d4be0f" id="r_gaf7c9e177bed083aa4c61b13b78d4be0f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf7c9e177bed083aa4c61b13b78d4be0f">mimicpp::ScopedSequence</a> = <a class="el" href="#ga9efea600d953c01de2d99d7d144264e4">LazyScopedSequence</a></td></tr>
<tr class="memdesc:gaf7c9e177bed083aa4c61b13b78d4be0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default scoped-sequence type (lazy strategy).  <br /></td></tr>
<tr class="separator:gaf7c9e177bed083aa4c61b13b78d4be0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6777ae3a4ea46f945ad2e998885a07c" id="r_gaf6777ae3a4ea46f945ad2e998885a07c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf6777ae3a4ea46f945ad2e998885a07c">mimicpp::SequenceT</a> = <a class="el" href="../../db/d46/classmimicpp_1_1_lazy_sequence.html">LazySequence</a></td></tr>
<tr class="memdesc:gaf6777ae3a4ea46f945ad2e998885a07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default sequence type (<a class="el" href="../../db/d46/classmimicpp_1_1_lazy_sequence.html" title="The lazy sequence interface.">LazySequence</a>).  <br /></td></tr>
<tr class="separator:gaf6777ae3a4ea46f945ad2e998885a07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaccf673d491adb8bec0694d4ead2bf91a" id="r_gaccf673d491adb8bec0694d4ead2bf91a"><td class="memTemplParams" colspan="2">template&lt;typename Id, auto priorityStrategy&gt; </td></tr>
<tr class="memitem:gaccf673d491adb8bec0694d4ead2bf91a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaccf673d491adb8bec0694d4ead2bf91a">mimicpp::expect::in_sequence</a> (sequence::detail::BasicSequenceInterface&lt; Id, priorityStrategy &gt; &amp;sequence) noexcept</td></tr>
<tr class="memdesc:gaccf673d491adb8bec0694d4ead2bf91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches the expectation onto a sequence.  <br /></td></tr>
<tr class="separator:gaccf673d491adb8bec0694d4ead2bf91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga000183a184796dbab88558e072a63f4d" id="r_ga000183a184796dbab88558e072a63f4d"><td class="memTemplParams" colspan="2">template&lt;typename FirstId, auto firstPriorityStrategy, typename SecondId, auto secondPriorityStrategy, typename... OtherIds, auto... otherPriorityStrategies&gt; </td></tr>
<tr class="memitem:ga000183a184796dbab88558e072a63f4d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga000183a184796dbab88558e072a63f4d">mimicpp::expect::in_sequences</a> (sequence::detail::BasicSequenceInterface&lt; FirstId, firstPriorityStrategy &gt; &amp;firstSequence, sequence::detail::BasicSequenceInterface&lt; SecondId, secondPriorityStrategy &gt; &amp;secondSequence, sequence::detail::BasicSequenceInterface&lt; OtherIds, otherPriorityStrategies &gt; &amp;... otherSequences)</td></tr>
<tr class="memdesc:ga000183a184796dbab88558e072a63f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches the expectation onto the listed sequences.  <br /></td></tr>
<tr class="separator:ga000183a184796dbab88558e072a63f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Sequences enable deterministic ordering between multiple expectations. </p>
<p>Their aim is to provide a convenient way for users, to circumvent the rather loosely ordering of expectations, which is by design. By default, if two or more expectations would match a call, the last created one is used. If multiple expectations are built one after another, that may be rather unintuitive design, but when it comes to scoping, it's usually preferable to match the expectations from within the current scope, even if there exist another similar expectation from the outside scope.</p>
<p>As I have no idea how to use one strategy for one case and the other for the other case, I decided to take the same route as <code>trompeloeil</code>. </p><dl class="section see"><dt>See also</dt><dd><a href="https://github.com/rollbear/trompeloeil/blob/main/docs/CookBook.md#sequences">https://github.com/rollbear/trompeloeil/blob/main/docs/CookBook.md#sequences</a></dd></dl>
<p>Either way, this is sometimes not enough, when we want to enforce deterministic ordering between two or more expectations. That's where sequences come into play. The expectation, which gets attached first must match before all subsequent expectations. If that one is fulfilled, the next one in the row must be matched; and so on. </p><div class="fragment"><div class="line">    <span class="keyword">namespace </span>matches = <a class="code hl_namespace" href="../../dd/d7b/namespacemimicpp_1_1matches.html">mimicpp::matches</a>;</div>
<div class="line">    <span class="keyword">namespace </span>expect = <a class="code hl_namespace" href="../../d3/d18/namespacemimicpp_1_1expect.html">mimicpp::expect</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;void(<span class="keywordtype">int</span>)&gt; mock{};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="#gaf6777ae3a4ea46f945ad2e998885a07c">mimicpp::SequenceT</a> sequence{};</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(matches::ne(0))</div>
<div class="line">        and expect::in_sequence(sequence);</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(matches::le(42))</div>
<div class="line">        and expect::in_sequence(sequence);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// a call with arg != 0 is expected before a call with arg &lt;= 42</span></div>
<div class="line">    mock(42); <span class="comment">// matches the first expectation</span></div>
<div class="line">    mock(0);  <span class="comment">// matches the second expectation</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// note: when we change the call order, the sequence would be violated</span></div>
</div><!-- fragment --><p>Sequences can also enforce orders on expectations, which refer to different mocks. </p><div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_variable" href="../../d4/d14/group___m_a_t_c_h_e_r_s.html#gaa74e274d126775d36dd9ebfd5879b61e">mimicpp::matches::_</a>;</div>
<div class="line">    <span class="keyword">namespace </span>expect = <a class="code hl_namespace" href="../../d3/d18/namespacemimicpp_1_1expect.html">mimicpp::expect</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;void(<span class="keywordtype">int</span>)&gt; mock1{};</div>
<div class="line">    <a class="code hl_class" href="../../d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;void(<span class="keywordtype">int</span>)&gt; mock2{};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="#gaf6777ae3a4ea46f945ad2e998885a07c">mimicpp::SequenceT</a> sequence{};</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock2.expect_call(_) <span class="comment">// mock2 must go first</span></div>
<div class="line">        and expect::in_sequence(sequence);</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock1.expect_call(_) <span class="comment">// mock1 must go second</span></div>
<div class="line">        and expect::in_sequence(sequence);</div>
<div class="line"> </div>
<div class="line">    mock2(42);</div>
<div class="line">    mock1(1337);</div>
</div><!-- fragment --><p>Sequenced and non-sequenced expectations may be arbitrarily mixed; even if this can be very difficult to trace, by simply reviewing the code. </p><div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_variable" href="../../d4/d14/group___m_a_t_c_h_e_r_s.html#gaa74e274d126775d36dd9ebfd5879b61e">mimicpp::matches::_</a>;</div>
<div class="line">    <span class="keyword">namespace </span>expect = <a class="code hl_namespace" href="../../d3/d18/namespacemimicpp_1_1expect.html">mimicpp::expect</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;void(<span class="keywordtype">int</span>)&gt; mock{};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(42); <span class="comment">// (1)</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(1337); <span class="comment">// (2)</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="#gaf6777ae3a4ea46f945ad2e998885a07c">mimicpp::SequenceT</a> sequence{};</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(1337) <span class="comment">// (3)</span></div>
<div class="line">        and expect::in_sequence(sequence);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(1337); <span class="comment">// (4)</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(42) <span class="comment">// (5)</span></div>
<div class="line">        and expect::in_sequence(sequence);</div>
<div class="line"> </div>
<div class="line">    mock(42);   <span class="comment">// matches (1), because (5) is the second element of the sequence</span></div>
<div class="line">    mock(1337); <span class="comment">// matches (4), because it&#39;s the &quot;youngest&quot; available alternative</span></div>
<div class="line">    mock(1337); <span class="comment">// matches (3), because it&#39;s &quot;younger&quot; than (2). So, the first element of the sequence got matched.</span></div>
<div class="line">    mock(42);   <span class="comment">// matches (5). The sequence is now fulfilled.</span></div>
<div class="line">    mock(1337); <span class="comment">// finally matches (2)</span></div>
</div><!-- fragment --><p><code><a class="el" href="#gaf7c9e177bed083aa4c61b13b78d4be0f" title="The default scoped-sequence type (lazy strategy).">ScopedSequence</a></code> simplifies the setup of sequences. This is actually equivalent to the previously demonstrated <code><a class="el" href="../../db/d46/classmimicpp_1_1_lazy_sequence.html" title="The lazy sequence interface.">LazySequence</a></code> example. </p><div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_variable" href="../../d4/d14/group___m_a_t_c_h_e_r_s.html#gaa74e274d126775d36dd9ebfd5879b61e">mimicpp::matches::_</a>;</div>
<div class="line">    <span class="keyword">namespace </span>expect = <a class="code hl_namespace" href="../../d3/d18/namespacemimicpp_1_1expect.html">mimicpp::expect</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;void()&gt; mock{};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="#gaf7c9e177bed083aa4c61b13b78d4be0f">mimicpp::ScopedSequence</a> sequence{};</div>
<div class="line">    sequence += mock.expect_call() <span class="comment">// (1)</span></div>
<div class="line">            and expect::at_most(1);</div>
<div class="line">    sequence += mock.expect_call(); <span class="comment">// (2)</span></div>
<div class="line"> </div>
<div class="line">    mock(); <span class="comment">// matches (1)</span></div>
<div class="line">    mock(); <span class="comment">// matches (2)</span></div>
</div><!-- fragment --><p>It's totally fine to attach expectations to sequences, which are already queried for matches. Sequences do not have to be setup in one go.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Thread-Safety</h1>
<p>Sequences are not thread-safe and are never intended to be. If one attempts to enforce a strong ordering between multiple threads without any explicit synchronisation, that attempt is doomed to fail.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
A word on sequences with times</h1>
<p>Sequences and times are fully compatible, but can quickly lead to very hard to understand flows. In general, when mixing sequences with exact times (like <a class="el" href="../../d7/d32/group___e_x_p_e_c_t_a_t_i_o_n___t_i_m_e_s.html#ga90e8c3c02fe9ec7f14a24a7c9c7e1695" title="Specifies a times policy with both limits set to 2.">expect::twice</a>) it will just work. But when users are defining very permissive expectations combined with ranging times (like binary <a class="el" href="../../d7/d32/group___e_x_p_e_c_t_a_t_i_o_n___t_i_m_e_s.html#ga842250d61be8ef526973a0ca246bf515" title="Specifies a times policy with a limit range.">expect::times</a>), that may lead to surprising behaviour.</p>
<p>Imagine a Sequence with two expectations; the first one with <code>min = 0</code> and <code>max = 1</code> and the second one with arbitrary limits. When a new call matches both expectations, which one should be preferred?</p>
<p>As a last resort, sequences come in two built-in flavors:</p><ul>
<li><a class="el" href="../../db/d46/classmimicpp_1_1_lazy_sequence.html" title="The lazy sequence interface.">LazySequence</a> (default)</li>
<li><a class="el" href="../../db/d43/classmimicpp_1_1_greedy_sequence.html" title="The greedy sequence interface.">GreedySequence</a></li>
</ul>
<p><a class="el" href="../../db/d46/classmimicpp_1_1_lazy_sequence.html" title="The lazy sequence interface.">LazySequence</a> is designed to make the least possible progress for a match, thus prefers not to skip sequence elements: </p><div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_variable" href="../../d4/d14/group___m_a_t_c_h_e_r_s.html#gaa74e274d126775d36dd9ebfd5879b61e">mimicpp::matches::_</a>;</div>
<div class="line">    <span class="keyword">namespace </span>expect = <a class="code hl_namespace" href="../../d3/d18/namespacemimicpp_1_1expect.html">mimicpp::expect</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;void()&gt; mock{};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../db/d46/classmimicpp_1_1_lazy_sequence.html">mimicpp::LazySequence</a> sequence{};</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call() <span class="comment">// (1)</span></div>
<div class="line">        and expect::in_sequence(sequence)</div>
<div class="line">        and expect::at_most(1);</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call() <span class="comment">// (2)</span></div>
<div class="line">        and expect::in_sequence(sequence);</div>
<div class="line"> </div>
<div class="line">    mock(); <span class="comment">// matches (1)</span></div>
<div class="line">    mock(); <span class="comment">// matches (2)</span></div>
</div><!-- fragment --><p><a class="el" href="../../db/d43/classmimicpp_1_1_greedy_sequence.html" title="The greedy sequence interface.">GreedySequence</a> does make the maximal possible progress for a match, thus prefers to skip sequence elements: </p><div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_variable" href="../../d4/d14/group___m_a_t_c_h_e_r_s.html#gaa74e274d126775d36dd9ebfd5879b61e">mimicpp::matches::_</a>;</div>
<div class="line">    <span class="keyword">namespace </span>expect = <a class="code hl_namespace" href="../../d3/d18/namespacemimicpp_1_1expect.html">mimicpp::expect</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;void()&gt; mock{};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../db/d43/classmimicpp_1_1_greedy_sequence.html">mimicpp::GreedySequence</a> sequence{};</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call() <span class="comment">// (1)</span></div>
<div class="line">        and expect::in_sequence(sequence)</div>
<div class="line">        and expect::at_most(1);</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call() <span class="comment">// (2)</span></div>
<div class="line">        and expect::in_sequence(sequence);</div>
<div class="line"> </div>
<div class="line">    mock(); <span class="comment">// matches (2)</span></div>
<div class="line">            <span class="comment">// no further call possible, because that would be out of sequence and will lead to an inapplicable match report!</span></div>
</div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="gaf9c4e7108a57906787965591f6064d82" name="gaf9c4e7108a57906787965591f6064d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9c4e7108a57906787965591f6064d82">&#9670;&#160;</a></span>GreedyScopedSequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaf9c4e7108a57906787965591f6064d82">mimicpp::GreedyScopedSequence</a> = <a class="el" href="../../d2/d48/classmimicpp_1_1_basic_scoped_sequence.html">BasicScopedSequence</a>&lt;sequence::detail::GreedyStrategy{}&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The scoped-sequence type with greedy strategy. </p>

</div>
</div>
<a id="ga9efea600d953c01de2d99d7d144264e4" name="ga9efea600d953c01de2d99d7d144264e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9efea600d953c01de2d99d7d144264e4">&#9670;&#160;</a></span>LazyScopedSequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga9efea600d953c01de2d99d7d144264e4">mimicpp::LazyScopedSequence</a> = <a class="el" href="../../d2/d48/classmimicpp_1_1_basic_scoped_sequence.html">BasicScopedSequence</a>&lt;sequence::detail::LazyStrategy{}&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The scoped-sequence type with lazy strategy. </p>

</div>
</div>
<a id="gaf7c9e177bed083aa4c61b13b78d4be0f" name="gaf7c9e177bed083aa4c61b13b78d4be0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7c9e177bed083aa4c61b13b78d4be0f">&#9670;&#160;</a></span>ScopedSequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaf7c9e177bed083aa4c61b13b78d4be0f">mimicpp::ScopedSequence</a> = <a class="el" href="#ga9efea600d953c01de2d99d7d144264e4">LazyScopedSequence</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default scoped-sequence type (lazy strategy). </p>

</div>
</div>
<a id="gaf6777ae3a4ea46f945ad2e998885a07c" name="gaf6777ae3a4ea46f945ad2e998885a07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6777ae3a4ea46f945ad2e998885a07c">&#9670;&#160;</a></span>SequenceT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaf6777ae3a4ea46f945ad2e998885a07c">mimicpp::SequenceT</a> = <a class="el" href="../../db/d46/classmimicpp_1_1_lazy_sequence.html">LazySequence</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default sequence type (<a class="el" href="../../db/d46/classmimicpp_1_1_lazy_sequence.html" title="The lazy sequence interface.">LazySequence</a>). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaccf673d491adb8bec0694d4ead2bf91a" name="gaccf673d491adb8bec0694d4ead2bf91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccf673d491adb8bec0694d4ead2bf91a">&#9670;&#160;</a></span>in_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Id, auto priorityStrategy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mimicpp::expect::in_sequence </td>
          <td>(</td>
          <td class="paramtype">sequence::detail::BasicSequenceInterface&lt; Id, priorityStrategy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sequence</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches the expectation onto a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>The sequence to be attached to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the expectation is already part of the given sequence.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">    <span class="keyword">namespace </span>matches = <a class="code hl_namespace" href="../../dd/d7b/namespacemimicpp_1_1matches.html">mimicpp::matches</a>;</div>
<div class="line">    <span class="keyword">namespace </span>expect = <a class="code hl_namespace" href="../../d3/d18/namespacemimicpp_1_1expect.html">mimicpp::expect</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;void(<span class="keywordtype">int</span>)&gt; mock{};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="#gaf6777ae3a4ea46f945ad2e998885a07c">mimicpp::SequenceT</a> sequence{};</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(matches::ne(0))</div>
<div class="line">        and expect::in_sequence(sequence);</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(matches::le(42))</div>
<div class="line">        and expect::in_sequence(sequence);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// a call with arg != 0 is expected before a call with arg &lt;= 42</span></div>
<div class="line">    mock(42); <span class="comment">// matches the first expectation</span></div>
<div class="line">    mock(0);  <span class="comment">// matches the second expectation</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// note: when we change the call order, the sequence would be violated</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_variable" href="../../d4/d14/group___m_a_t_c_h_e_r_s.html#gaa74e274d126775d36dd9ebfd5879b61e">mimicpp::matches::_</a>;</div>
<div class="line">    <span class="keyword">namespace </span>expect = <a class="code hl_namespace" href="../../d3/d18/namespacemimicpp_1_1expect.html">mimicpp::expect</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;void(<span class="keywordtype">int</span>)&gt; mock{};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(42); <span class="comment">// (1)</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(1337); <span class="comment">// (2)</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="#gaf6777ae3a4ea46f945ad2e998885a07c">mimicpp::SequenceT</a> sequence{};</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(1337) <span class="comment">// (3)</span></div>
<div class="line">        and expect::in_sequence(sequence);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(1337); <span class="comment">// (4)</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(42) <span class="comment">// (5)</span></div>
<div class="line">        and expect::in_sequence(sequence);</div>
<div class="line"> </div>
<div class="line">    mock(42);   <span class="comment">// matches (1), because (5) is the second element of the sequence</span></div>
<div class="line">    mock(1337); <span class="comment">// matches (4), because it&#39;s the &quot;youngest&quot; available alternative</span></div>
<div class="line">    mock(1337); <span class="comment">// matches (3), because it&#39;s &quot;younger&quot; than (2). So, the first element of the sequence got matched.</span></div>
<div class="line">    mock(42);   <span class="comment">// matches (5). The sequence is now fulfilled.</span></div>
<div class="line">    mock(1337); <span class="comment">// finally matches (2)</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga000183a184796dbab88558e072a63f4d" name="ga000183a184796dbab88558e072a63f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga000183a184796dbab88558e072a63f4d">&#9670;&#160;</a></span>in_sequences()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FirstId, auto firstPriorityStrategy, typename SecondId, auto secondPriorityStrategy, typename... OtherIds, auto... otherPriorityStrategies&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mimicpp::expect::in_sequences </td>
          <td>(</td>
          <td class="paramtype">sequence::detail::BasicSequenceInterface&lt; FirstId, firstPriorityStrategy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>firstSequence</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sequence::detail::BasicSequenceInterface&lt; SecondId, secondPriorityStrategy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>secondSequence</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sequence::detail::BasicSequenceInterface&lt; OtherIds, otherPriorityStrategies &gt; &amp;...</td>          <td class="paramname"><span class="paramname"><em>otherSequences</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches the expectation onto the listed sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstSequence</td><td>The first sequence to be attached to. </td></tr>
    <tr><td class="paramname">secondSequence</td><td>The second sequence to be attached to. </td></tr>
    <tr><td class="paramname">otherSequences</td><td>Other sequences to be attached to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the expectation is already attached to any of the given sequences or the given sequences contain duplicates.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_variable" href="../../d4/d14/group___m_a_t_c_h_e_r_s.html#gaa74e274d126775d36dd9ebfd5879b61e">mimicpp::matches::_</a>;</div>
<div class="line">    <span class="keyword">namespace </span>expect = <a class="code hl_namespace" href="../../d3/d18/namespacemimicpp_1_1expect.html">mimicpp::expect</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;void()&gt; mock{};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="#gaf6777ae3a4ea46f945ad2e998885a07c">mimicpp::SequenceT</a> sequence1{};</div>
<div class="line">    <a class="code hl_typedef" href="#gaf6777ae3a4ea46f945ad2e998885a07c">mimicpp::SequenceT</a> sequence2{};</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call() <span class="comment">// (1)</span></div>
<div class="line">        and expect::in_sequence(sequence1);</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call() <span class="comment">// (2)</span></div>
<div class="line">        and expect::in_sequences(sequence1, sequence2);</div>
<div class="line">    <a class="code hl_define" href="../../d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call() <span class="comment">// (3)</span></div>
<div class="line">        and expect::in_sequence(sequence2);</div>
<div class="line"> </div>
<div class="line">    mock(); <span class="comment">// (1) is used here, because (3) is second in sequence2 and (2) is second in sequence1</span></div>
<div class="line">    mock(); <span class="comment">// (2) is used here, because it&#39;s the first in both sequences now</span></div>
<div class="line">    mock(); <span class="comment">// now (3) is used</span></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Jun 26 2025 for mimic++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
