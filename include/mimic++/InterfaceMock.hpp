//          Copyright Dominic (DNKpp) Koepke 2024 - 2025.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          https://www.boost.org/LICENSE_1_0.txt)

#ifndef MIMICPP_INTERFACE_MOCK_HPP
#define MIMICPP_INTERFACE_MOCK_HPP

#pragma once

#include "mimic++/Fwd.hpp"
#include "mimic++/Mock.hpp"
#include "mimic++/config/Config.hpp"
#include "mimic++/macros/InterfaceMocking.hpp"
#include "mimic++/printing/TypePrinter.hpp"
#include "mimic++/utilities/TypeList.hpp"

#ifndef MIMICPP_DETAIL_IS_MODULE
    #include <cstddef>
    #include <iterator>
    #include <tuple>
    #include <type_traits>
    #include <utility>
#endif

namespace mimicpp
{
    /**
     * \defgroup MOCK_INTERFACES interfaces
     * \ingroup MOCK
     * \brief Contains utility to simplify interface mocking.
     * \details While this library tries avoiding macros when possible, sometimes we must not be too stubborn.
     * Making interface mocking more enjoyable is such a situation. While this can of course be done without macros,
     * this quickly becomes annoying, due to the necessary boilerplate code.
     * \snippet InterfaceMock.cpp interface mock manual
     * ``mimic++`` therefore introduces some macros, which helps to reduce the effort to a minimum.
     * With them, the boilerplate can be reduced to this macro invocation, which effectively does the same as before:
     * ```cpp
     * MOCK_METHOD(foo, void, ());
     * ```
     *
     * The good news is, that these macros are just a thin layer around the macro free core and can thus be easily avoided.
     * Nevertheless, ``mimic++`` still aims to become macro-less as possible. As soon as reflection becomes available, an
     * attempt will be made to solve this feature completely in c++ language (hopefully with c++26, but only time will tell).
     *
     * ## Multiple inheritance
     * Multiple inheritance is fully supported, without any special tricks.
     * \snippet InterfaceMock.cpp interface mock multiple inheritance
     * \details
     * ## Mocks and variadic templates
     * Due to the nature of the ``mimicpp::Mock`` design, they directly supports packs without any question.
     * \snippet VariadicMocks.cpp variadic mock def
     * \snippet VariadicMocks.cpp variadic mock
     *
     * The interesting part is: Do ``MIMICPP_MOCK_METHOD`` and ``MIMICPP_MOCK_OVERLOADED_METHOD`` also support variadic templates?
     *
     * Yes they do! Both handle packs correctly.
     * \snippet VariadicMocks.cpp variadic interface def
     *
     * They can then be used with arbitrary template arguments.
     * \snippet VariadicMocks.cpp variadic interface zero
     * \snippet VariadicMocks.cpp variadic interface 2
     */
}

// These symbols are called from within "exported" macros and must thus be visible to the caller.
MIMICPP_DETAIL_MODULE_EXPORT namespace mimicpp::detail
{
    // Removes the following stacktrace-entries from stacktraces generated by interface mocks:
    // * detail::indirectly_apply_mock
    // * detail::indirectly_apply_mock::lambda
    // * detail::traits::invoke
    // * the generated interface implementation
    inline constexpr std::size_t interfaceMockStacktraceSkip{4u};

    template <typename Self>
    [[nodiscard]]
    StringT generate_interface_mock_name(StringViewT const functionName)
    {
        StringStreamT ss{};
        mimicpp::print_type<Self>(std::ostreambuf_iterator{ss});
        ss << "::" << functionName;

        return std::move(ss).str();
    }

    /**
     * \brief Applies the given args on the mock.
     * \details This function helps with the general apply procedure of the mock.
     * It casts it to the correct reference and forwards the arguments.
     * Additionally, this helps letting mimic++ reliably know, how many entries we need to skip from the stacktrace,
     * as the general implementation of ``std::apply`` varies.
     * That's also the reason, why no ``std::invoke`` is used here.
     */
    template <typename Signature, typename Mock, typename... Args>
    constexpr signature_return_type_t<Signature> indirectly_apply_mock(Mock & mock, std::tuple<Args...> && args)
    {
        using mock_ref_t = std::conditional_t<
            ValueCategory::rvalue == signature_ref_qualification_v<Signature>,
            Mock&&,
            Mock&>;
        const auto forward_apply = [&]<std::size_t... indices>([[maybe_unused]] std::index_sequence<indices...> const)
            -> signature_return_type_t<Signature> {
            return static_cast<mock_ref_t>(mock)(
                std::forward<Args>(std::get<indices>(args))...);
        };

        constexpr auto sequence = std::index_sequence_for<Args...>{};
        return forward_apply(sequence);
    }

    struct interface_mock_traits
    {
        template <typename... Signatures>
        using mock_type = Mock<Signatures...>;

        template <typename Signature, typename... Args>
        static constexpr signature_return_type_t<Signature> invoke(
            auto& mock,
            [[maybe_unused]] auto* self,
            std::tuple<Args...>&& args)
        {
            return indirectly_apply_mock<Signature>(mock, std::move(args));
        }

        [[nodiscard]]
        static MockSettings make_settings(auto const& self, StringViewT const functionName)
        {
            return MockSettings{
                .name = generate_interface_mock_name<std::remove_cvref_t<decltype(self)>>(functionName),
                .stacktraceSkip = interfaceMockStacktraceSkip};
        }
    };

    template <typename Self>
    struct interface_mock_with_this_traits
    {
        template <typename Signature, bool isConst = Constness::as_const == signature_const_qualification_v<Signature>>
        using prepend_this = signature_prepend_param_t<
            Signature,
            std::conditional_t<isConst, Self const*, Self*>>;

        template <typename... Signatures>
        using mock_type = Mock<prepend_this<Signatures>...>;

        template <typename Signature, typename... Args>
        static constexpr signature_return_type_t<Signature> invoke(auto& mock, auto* self, std::tuple<Args...>&& args)
        {
            return indirectly_apply_mock<Signature>(
                mock,
                std::tuple_cat(std::make_tuple(self), std::move(args)));
        }

        [[nodiscard]]
        static MockSettings make_settings([[maybe_unused]] auto const& self, StringViewT const functionName)
        {
            return MockSettings{
                .name = generate_interface_mock_name<Self>(functionName),
                .stacktraceSkip = interfaceMockStacktraceSkip};
        }
    };
}

#endif
