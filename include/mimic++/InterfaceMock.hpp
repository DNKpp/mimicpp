//          Copyright Dominic (DNKpp) Koepke 2024 - 2025.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          https://www.boost.org/LICENSE_1_0.txt)

#ifndef MIMICPP_INTERFACE_MOCK_HPP
#define MIMICPP_INTERFACE_MOCK_HPP

#pragma once

#include "mimic++/Fwd.hpp"
#include "mimic++/Mock.hpp"
#include "mimic++/config/Config.hpp"
#include "mimic++/macros/InterfaceMocking.hpp"
#include "mimic++/printing/TypePrinter.hpp"
#include "mimic++/utilities/AlwaysFalse.hpp"
#include "mimic++/utilities/StaticString.hpp"
#include "mimic++/utilities/TypeList.hpp"

#ifndef MIMICPP_DETAIL_IS_MODULE
    #include <cstddef>
    #include <iterator>
    #include <tuple>
    #include <type_traits>
    #include <utility>
#endif

namespace mimicpp
{
    /**
     * \defgroup MOCK_INTERFACES interfaces
     * \ingroup MOCK
     * \brief Contains utility to simplify interface mocking.
     * \details While this library tries avoiding macros when possible, sometimes we must not be too stubborn.
     * Making interface mocking more enjoyable is such a situation. While this can of course be done without macros,
     * this quickly becomes annoying, due to the necessary boilerplate code.
     * \snippet InterfaceMock.cpp interface mock manual
     * ``mimic++`` therefore introduces some macros, which helps to reduce the effort to a minimum.
     * With them, the boilerplate can be reduced to this macro invocation, which effectively does the same as before:
     * ```cpp
     * MOCK_METHOD(foo, void, ());
     * ```
     *
     * The good news is, that these macros are just a thin layer around the macro free core and can thus be easily avoided.
     * Nevertheless, ``mimic++`` still aims to become macro-less as possible. As soon as reflection becomes available, an
     * attempt will be made to solve this feature completely in c++ language (hopefully with c++26, but only time will tell).
     *
     * ## Multiple inheritance
     * Multiple inheritance is fully supported, without any special tricks.
     * \snippet InterfaceMock.cpp interface mock multiple inheritance
     * \details
     * ## Mocks and variadic templates
     * Due to the nature of the ``mimicpp::Mock`` design, they directly supports packs without any question.
     * \snippet VariadicMocks.cpp variadic mock def
     * \snippet VariadicMocks.cpp variadic mock
     *
     * The interesting part is: Do ``MIMICPP_MOCK_METHOD`` and ``MIMICPP_MOCK_OVERLOADED_METHOD`` also support variadic templates?
     *
     * Yes they do! Both handle packs correctly.
     * \snippet VariadicMocks.cpp variadic interface def
     *
     * They can then be used with arbitrary template arguments.
     * \snippet VariadicMocks.cpp variadic interface zero
     * \snippet VariadicMocks.cpp variadic interface 2
     */
}

// These symbols are called from within "exported" macros and must thus be visible to the caller.
MIMICPP_DETAIL_MODULE_EXPORT namespace mimicpp::detail
{
    // Removes the following stacktrace-entries from stacktraces generated by interface mocks:
    // * detail::indirectly_apply_mock
    // * detail::indirectly_apply_mock::lambda
    // * detail::traits::invoke
    // * the generated interface implementation - lambda
    // * the generated interface implementation
    inline constexpr std::size_t interfaceMockStacktraceSkip{5u};

    template <typename Self>
    [[nodiscard]]
    StringT generate_interface_mock_name(StringViewT const functionName)
    {
        StringStreamT ss{};
        mimicpp::print_type<Self>(std::ostreambuf_iterator{ss});
        ss << "::" << functionName;

        return std::move(ss).str();
    }

    /**
     * \brief Applies the given args on the mock.
     * \details This function helps with the general apply procedure of the mock.
     * It casts it to the correct reference and forwards the arguments.
     * Additionally, this helps letting mimic++ reliably know, how many entries we need to skip from the stacktrace,
     * as the general implementation of ``std::apply`` varies.
     * That's also the reason, why no ``std::invoke`` is used here.
     */
    template <typename Signature, typename Mock, typename... Args>
    constexpr decltype(auto) indirectly_apply_mock(Mock & mock, std::tuple<Args...> && args)
    {
        using mock_ref_t = std::conditional_t<
            ValueCategory::rvalue == signature_ref_qualification_v<Signature>,
            Mock&&,
            Mock&>;

        return [&]<std::size_t... indices>([[maybe_unused]] std::index_sequence<indices...> const) -> decltype(auto) {
            return static_cast<mock_ref_t>(mock)(std::forward<Args>(std::get<indices>(args))...);
        }(std::index_sequence_for<Args...>{});
    }

    template <typename Traits>
    inline constexpr bool is_member_facade_v = false;

    template <typename Traits>
        requires requires { Traits::is_member; }
    inline constexpr bool is_member_facade_v<Traits>{Traits::is_member};

    struct interface_mock_traits
    {
        static constexpr bool is_member{true};

        template <typename... Signatures>
        using mock_type = Mock<Signatures...>;

        template <typename Signature, typename... Args>
        static constexpr decltype(auto) invoke(
            auto& mock,
            [[maybe_unused]] auto* self,
            std::tuple<Args...>&& args)
        {
            return indirectly_apply_mock<Signature>(mock, std::move(args));
        }

        template <typename Self>
        [[nodiscard]]
        static MockSettings make_settings([[maybe_unused]] Self const* const self, StringViewT const functionName)
        {
            return MockSettings{
                .name = generate_interface_mock_name<Self>(functionName),
                .stacktraceSkip = interfaceMockStacktraceSkip};
        }
    };

    template <typename Self>
    struct interface_mock_with_this_traits
    {
        static constexpr bool is_member{true};

        template <typename Signature, bool isConst = Constness::as_const == signature_const_qualification_v<Signature>>
        using prepend_this = signature_prepend_param_t<
            Signature,
            std::conditional_t<isConst, Self const*, Self*>>;

        template <typename... Signatures>
        using mock_type = Mock<prepend_this<Signatures>...>;

        template <typename Signature, typename... Args>
        static constexpr decltype(auto) invoke(auto& mock, auto* self, std::tuple<Args...>&& args)
        {
            return indirectly_apply_mock<Signature>(
                mock,
                std::tuple_cat(std::make_tuple(self), std::move(args)));
        }

        [[nodiscard]]
        static MockSettings make_settings([[maybe_unused]] auto const* const self, StringViewT const functionName)
        {
            return MockSettings{
                .name = generate_interface_mock_name<Self>(functionName),
                .stacktraceSkip = interfaceMockStacktraceSkip};
        }
    };

    template <auto specText>
    struct apply_normalized_specs
    {
        [[nodiscard]]
        static consteval auto evaluate_specs()
        {
            constexpr std::string_view constKeyword{"const"};
            constexpr std::string_view noexceptKeyword{"noexcept"};
            constexpr std::string_view overrideKeyword{"override"};
            constexpr std::string_view finalKeyword{"final"};

            auto const end = std::ranges::end(specText);
            auto const find_token_begin = [&](auto const first) noexcept {
                constexpr auto is_space = [](char const c) noexcept {
                    return ' ' == c || '\t' == c;
                };

                return std::ranges::find_if_not(first, end, is_space);
            };

            struct spec_info
            {
                bool hasConst{false};
                ValueCategory refQualifier = ValueCategory::any;
                bool hasNoexcept;
            };

            spec_info result{};
            for (auto tokenBegin = find_token_begin(std::ranges::begin(specText));
                 tokenBegin != end;
                 tokenBegin = find_token_begin(tokenBegin))
            {
                if ('&' == *tokenBegin)
                {
                    MIMICPP_ASSERT(result.refQualifier == ValueCategory::any, "Ref-qualifier already set.");
                    if (++tokenBegin != end
                        && '&' == *tokenBegin)
                    {
                        ++tokenBegin;
                        result.refQualifier = ValueCategory::rvalue;
                    }
                    else
                    {
                        result.refQualifier = ValueCategory::lvalue;
                    }
                }
                else
                {
                    constexpr auto is_word_continue = [](char const c) noexcept {
                        return ('a' <= c && c <= 'z')
                            || ('A' <= c && c <= 'Z');
                    };
                    std::string_view const token{
                        tokenBegin,
                        std::ranges::find_if_not(tokenBegin, end, is_word_continue)};
                    if (constKeyword == token)
                    {
                        MIMICPP_ASSERT(!result.hasConst, "Const-qualifier already set.");
                        result.hasConst = true;
                    }
                    else if (noexceptKeyword == token)
                    {
                        MIMICPP_ASSERT(!result.hasNoexcept, "Noexcept-qualifier already set.");
                        result.hasNoexcept = true;
                    }
                    else if (overrideKeyword != token && finalKeyword != token)
                    {
                        throw std::runtime_error{"Invalid spec"};
                    }

                    tokenBegin = token.cend();
                }
            }

            return result;
        }

        static constexpr auto info = evaluate_specs();

    public:
        template <typename Signature>
        [[nodiscard]]
        static consteval auto evaluate() noexcept
        {
            using sig_maybe_ref = std::conditional_t<
                ValueCategory::lvalue == info.refQualifier,
                signature_add_lvalue_ref_qualifier_t<Signature>,
                std::conditional_t<
                    ValueCategory::rvalue == info.refQualifier,
                    signature_add_rvalue_ref_qualifier_t<Signature>,
                    Signature>>;

            using sig_maybe_const = std::conditional_t<
                info.hasConst,
                signature_add_const_qualifier_t<sig_maybe_ref>,
                sig_maybe_ref>;

            using sig_maybe_noexcept = std::conditional_t<
                info.hasNoexcept,
                signature_add_noexcept_t<sig_maybe_const>,
                sig_maybe_const>;

            return std::type_identity<sig_maybe_noexcept>{};
        }

        template <typename Signature>
        using type = decltype(evaluate<Signature>())::type;
    };

    template <typename RawSignature, auto specText>
    using apply_normalized_specs_t = apply_normalized_specs<specText>::template type<RawSignature>;
}

#endif
