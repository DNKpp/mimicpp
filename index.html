<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mimic++: mimic++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">mimic++<span id="projectnumber">&#160;v7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">mimic++ </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2github_2workspace_2_r_e_a_d_m_e"></a> <img src="https://github.com/user-attachments/assets/312220b7-c966-484f-b531-13721db998de" alt="logo" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md46"></a>
mimic++, a modern and (mostly) macro free mocking framework</h1>
<h3><a class="anchor" id="autotoc_md47"></a>
‚úÖ Quality</h3>
<p>‚ñë‚ñí‚ñí‚ñì‚ñì‚ñà‚ñà&#160;&#160;&#160; <a href="https://github.com/DNKpp/mimicpp/actions/workflows/codeql.yml"><img src="https://github.com/DNKpp/mimicpp/actions/workflows/codeql.yml/badge.svg" alt="CodeQL" style="pointer-events: none;" class="inline"/> </a> &#160;&#160; <a href="https://app.codacy.com/gh/DNKpp/mimicpp/dashboard"><img src="https://app.codacy.com/project/badge/Grade/b852271c6e8742fe8a1667e679dc422b" alt="Codacy Grade" class="inline"/> </a> &#160;&#160; <a href="https://app.codacy.com/gh/DNKpp/mimicpp/dashboard"><img src="https://app.codacy.com/project/badge/Coverage/b852271c6e8742fe8a1667e679dc422b" alt="Codacy Coverage" class="inline"/> </a> &#160;&#160; <a href="https://codecov.io/gh/DNKpp/mimicpp"><img src="https://codecov.io/gh/DNKpp/mimicpp/graph/badge.svg?token=T9EpgyuyUi" alt="Codecov" style="pointer-events: none;" class="inline"/> </a> &#160;&#160; <a href="https://coveralls.io/github/DNKpp/mimicpp"><img src="https://coveralls.io/repos/github/DNKpp/mimicpp/badge.svg" alt="Coveralls" style="pointer-events: none;" class="inline"/> </a> &#160;&#160;&#160;‚ñà‚ñà‚ñì‚ñì‚ñí‚ñí‚ñë </p>
<h3><a class="anchor" id="autotoc_md48"></a>
üîó Developer Hub</h3>
<p>Quick access to <b>documentation, package managers, and community support</b>.</p>
<p>&#160;&#160;&#160;&#160;‚ïå üõ†Ô∏è ‚ïç‚ïå&#160;&#160; <a href="https://godbolt.org/z/63nhG1Mx3"><img src="https://img.shields.io/badge/try%20it-On%20Compiler%20Explorer-brightgreen?style=flat&amp;logo=compilerexplorer" alt="Compiler Explorer" class="inline"/> </a> &#160;&#160; <a href="https://vcpkg.link/ports/mimicpp"><img src="https://img.shields.io/vcpkg/v/mimicpp" alt="vcpkg" class="inline"/> </a> </p>
<p>&#160;&#160;&#160;&#160;‚ïå üí¨ ‚ïç‚ïå&#160;&#160; <a href="https://discord.gg/Gcay9n444E"><img src="https://img.shields.io/badge/join-Community%20Discord-%235865F2?style=flat&amp;logo=discord&amp;logoColor=%235865F2" alt="discord" class="inline"/> </a> &#160;&#160;&#160;&#160;&#160;&#160; <a href="https://github.com/DNKpp/mimicpp/discussions/new?category=q-a"><img src="https://img.shields.io/badge/ask-On%20Github-%23009999?style=flat&amp;logo=github" alt="discussion" class="inline"/> </a> </p>
<p>&#160;&#160;&#160;&#160;‚ïå üìñ ‚ïç‚ïå&#160;&#160; <a href="https://dnkpp.github.io/mimicpp/"><img src="https://img.shields.io/badge/read_-Online%20Documentation-%239B59B6?style=flat&amp;logo=readme&amp;logoColor=silver" alt="docs" class="inline"/> </a> </p>
<hr  />
<h2><a class="anchor" id="autotoc_md50"></a>
Table of Contents</h2>
<ul>
<li>Introduction<ul>
<li>Core Design</li>
<li>Quick Demo</li>
<li>Examples</li>
</ul>
</li>
<li>Features &amp; Customizability<ul>
<li>Stringification</li>
<li>Matchers</li>
<li>Policies</li>
<li>Bring your own string- and char-types</li>
<li>Call-Conventions</li>
</ul>
</li>
<li>Integration<ul>
<li>Portability</li>
<li>CMake</li>
<li>Packaging Tools</li>
<li>Single-Header</li>
<li>Test Framework</li>
<li>Documentation</li>
</ul>
</li>
<li>Testing</li>
<li>Known Issues</li>
<li>Special Acknowledgement</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md52"></a>
Introduction</h2>
<p><code>mimic++</code> is a C++20 mocking framework designed to offer a natural and expressive syntax. While many similar frameworks aim for this goal, they often rely heavily on an extensive list of macros. Although macros can be beneficial, <code>mimic++</code> strives to minimize their usage to enhance readability and maintainability.</p>
<p>What sets <code>mimic++</code> apart from other mocking frameworks is its unique approach: Mock objects are explicitly defined as function objects, making them directly callable and overloadable. This design choice ensures that the framework remains extensible and straightforward to use.</p>
<p>If you're curious to learn more, feel free to explore the <a href="https://dnkpp.github.io/mimicpp/">documentation</a> and the cheat-sheet of to the latest release. You can also check out the examples folder or experiment with the framework online at <a href="https://godbolt.org/z/fYavvqfeM">godbolt.org</a>.</p>
<h3><a class="anchor" id="autotoc_md53"></a>
Core Design</h3>
<p>The framework is built around two core concepts: <b>Mocks</b> and <b>Expectations</b>.</p>
<p><b>Mocks</b> are objects that simulate functional implementations, allowing you to set up behavior on a per-test-case basis. These behaviors are referred to as <b>Expectations</b>, which define whether and how the mock should respond during testing.</p>
<p>The framework diligently tracks all Expectations and reports any that are either violated or left unfulfilled, providing useful information for debugging. This tracking mechanism helps developers quickly identify issues in their tests, ensuring that the intended behavior is accurately represented and maintained.</p>
<p>In essence, Mocks and Expectations work hand in hand to facilitate effective testing.</p>
<h3><a class="anchor" id="autotoc_md54"></a>
Quick Demo</h3>
<p>A robust mocking framework must effectively notify users of errors by providing all relevant details ‚Äî without overwhelming them with excessive verbosity.</p>
<p>Significant effort has been invested in ensuring that error messages, particularly type information, are clear, well-structured, and easy to interpret.</p>
<p>Consider the following example where a user creates a Mock object without setting up any expectations, and then proceeds to call it:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;void()&gt; mock{}; <span class="comment">// Create a mock without setting up any expectations.</span></div>
<div class="line">mock();                       <span class="comment">// Since no expectation was set up, this call is unmatched.</span></div>
<div class="ttc" id="aclassmimicpp_1_1_mock_html"><div class="ttname"><a href="d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a></div><div class="ttdoc">A Mock type, which fully supports overload sets.</div><div class="ttdef"><b>Definition</b> Mock.hpp:454</div></div>
</div><!-- fragment --><p>The framework will generate the following output:</p>
<div class="fragment"><div class="line">Unmatched Call originated from `path/to/source.cpp`#L1337, `test_function()`</div>
<div class="line">  On Target `Mock&lt;void()&gt;` used Overload `void()`</div>
<div class="line">No Expectations available!</div>
<div class="line"> </div>
<div class="line">Stacktrace:</div>
<div class="line">#0 `path/to/source.cpp`#L1337, `test_function()`</div>
<div class="line">// ...</div>
</div><!-- fragment --><p>In another scenario, when an expectation has been defined but the incoming call fails to meet any of the set criteria, it is crucial to clearly indicate where the mismatch occurred. For instance, in the example below the framework expects a call with the argument 42, but receives 1337 instead:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;void(<span class="keywordtype">int</span>, std::optional&lt;int&gt;)&gt; mock{}; <span class="comment">// Create a mock that expects `int` and `std::optional&lt;int&gt;` as argument.</span></div>
<div class="line"><span class="comment">// Set up an expectation:</span></div>
<div class="line"><a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(42, std::nullopt);       <span class="comment">// The mock should be called with `42` and `nullopt`.</span></div>
<div class="line">mock(1337, std::nullopt);                            <span class="comment">// Call the mock with an incorrect argument (`1337` instead of `42`).</span></div>
<div class="ttc" id="agroup___m_o_c_k_html_ga7e7d68eefb8f3cba28422f62bcf2f90a"><div class="ttname"><a href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a></div><div class="ttdeci">#define SCOPED_EXP</div><div class="ttdoc">Shorthand variant of MIMICPP_SCOPED_EXPECTATION.</div><div class="ttdef"><b>Definition</b> ExpectationBuilder.hpp:309</div></div>
</div><!-- fragment --><p>This will produce the following detailed output:</p>
<div class="fragment"><div class="line">Unmatched Call originated from `path/to/source.cpp`#L42, `test_function2()`</div>
<div class="line">  On Target `Mock&lt;void(int)&gt;` used Overload `void(int)`</div>
<div class="line">  Where:</div>
<div class="line">      arg[0] =&gt; int: 1337</div>
<div class="line">      arg[1] =&gt; std::optional&lt;int&gt;: nullopt</div>
<div class="line">1 non-matching Expectation(s):</div>
<div class="line">  #1 Expectation defined at `path/to/source.cpp`#L24, `test_function2()`</div>
<div class="line">  Due to Violation(s):</div>
<div class="line">    - expect: arg[0] == 42</div>
<div class="line">  With Adherence(s):</div>
<div class="line">    + expect: arg[1] == nullopt</div>
<div class="line"> </div>
<div class="line">Stacktrace:</div>
<div class="line">#0 `path/to/source.cpp`#L42, `test_function2()`</div>
<div class="line">// ...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md55"></a>
Examples</h3>
<details >
<summary >
Mocks as function objects</summary>
<p></p>
<p>As mentioned earlier, <code><a class="el" href="d2/d48/classmimicpp_1_1_mock.html" title="A Mock type, which fully supports overload sets.">mimicpp::Mock</a></code> objects are actual function objects and can be used directly.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="d0/db9/mimic_09_09_8hpp.html">mimic++/mimic++.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// It is recommended to pull these sub-namespaces out, as doing so enhances the readability of the expectation setup.</span></div>
<div class="line"><span class="keyword">namespace </span>expect = <a class="code hl_namespace" href="d3/d18/namespacemimicpp_1_1expect.html">mimicpp::expect</a>;</div>
<div class="line"><span class="keyword">namespace </span>matches = <a class="code hl_namespace" href="dd/d7b/namespacemimicpp_1_1matches.html">mimicpp::matches</a>;</div>
<div class="line"><span class="keyword">namespace </span>finally = <a class="code hl_namespace" href="d2/d8d/namespacemimicpp_1_1finally.html">mimicpp::finally</a>;</div>
<div class="line"><span class="keyword">namespace </span>then = <a class="code hl_namespace" href="d9/d4c/namespacemimicpp_1_1then.html">mimicpp::then</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>matches::_;   <span class="comment">// That&#39;s the wildcard matcher, which matches anything.</span></div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;Mocks are function objects.&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;int(std::string, std::optional&lt;int&gt;)&gt; mock{};     <span class="comment">// This enables the `int operator ()(std::string, std::optional&lt;int&gt;)` member.</span></div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(<span class="stringliteral">&quot;Hello, World&quot;</span>, _)                  <span class="comment">// This requires the first argument to match the string &quot;Hello, World,&quot; while the second argument has no restrictions.</span></div>
<div class="line">                and expect::at_least(1)                             <span class="comment">// This specifies that the expectation must be matched one or more times.</span></div>
<div class="line">                and expect::arg&lt;0&gt;(!matches::range::is_empty())     <span class="comment">// Additionally, it requires the first argument to be non-empty (note the preceding !),</span></div>
<div class="line">                and expect::arg&lt;1&gt;(matches::ne(std::nullopt))       <span class="comment">// This requires that the second argument is not std::nullopt...</span></div>
<div class="line">                and expect::arg&lt;1&gt;(matches::lt(1337))               <span class="comment">// ... and is less than 1337.</span></div>
<div class="line">                and then::apply_arg&lt;0&gt;(                             <span class="comment">// That&#39;s a side effect that gets executed when a match is made.</span></div>
<div class="line">                    [](std::string_view str) { std::cout &lt;&lt; str; }) <span class="comment">//     This one writes the content of the first argument to std::cout.</span></div>
<div class="line">                and finally::returns(42);                           <span class="comment">// It eventually returns 42 for each match.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> result = mock(<span class="stringliteral">&quot;Hello, World&quot;</span>, 1336);                        <span class="comment">// This matches the expectation.</span></div>
<div class="line">    REQUIRE(42 == result);</div>
<div class="line">}</div>
<div class="ttc" id="amimic_09_09_8hpp_html"><div class="ttname"><a href="d0/db9/mimic_09_09_8hpp.html">mimic++.hpp</a></div></div>
<div class="ttc" id="anamespacemimicpp_1_1expect_html"><div class="ttname"><a href="d3/d18/namespacemimicpp_1_1expect.html">mimicpp::expect</a></div><div class="ttdef"><b>Definition</b> ArgRequirementPolicies.hpp:124</div></div>
<div class="ttc" id="anamespacemimicpp_1_1finally_html"><div class="ttname"><a href="d2/d8d/namespacemimicpp_1_1finally.html">mimicpp::finally</a></div><div class="ttdef"><b>Definition</b> FinalizerPolicies.hpp:79</div></div>
<div class="ttc" id="anamespacemimicpp_1_1matches_html"><div class="ttname"><a href="dd/d7b/namespacemimicpp_1_1matches.html">mimicpp::matches</a></div><div class="ttdef"><b>Definition</b> FloatingPointMatchers.hpp:22</div></div>
<div class="ttc" id="anamespacemimicpp_1_1then_html"><div class="ttname"><a href="d9/d4c/namespacemimicpp_1_1then.html">mimicpp::then</a></div><div class="ttdef"><b>Definition</b> SideEffectPolicies.hpp:73</div></div>
</div><!-- fragment --><p><code><a class="el" href="d2/d48/classmimicpp_1_1_mock.html" title="A Mock type, which fully supports overload sets.">mimicpp::Mock</a></code> also supports arbitrary overload-sets, enabling an <code>operator()</code> for each specified signature.</p>
<div class="fragment"><div class="line">TEST_CASE(<span class="stringliteral">&quot;Mocks can be overloaded.&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;</div>
<div class="line">        int(std::string, std::optional&lt;int&gt;),                   <span class="comment">// This uses the same signature as the previous test.</span></div>
<div class="line">        void() const                                            <span class="comment">// Additionally, it enables void operator()() const (note the const specification).</span></div>
<div class="line">    &gt; mock{};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call()                               <span class="comment">// This sets up an expectation for the void() overload...</span></div>
<div class="line">                and expect::twice();                            <span class="comment">// ... which must be matched twice.</span></div>
<div class="line"> </div>
<div class="line">    mock();                                                     <span class="comment">// This matches the expectation once.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// You can create new expectations as needed, even if the mock object is already in use.</span></div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(!matches::range::is_empty(), 42)        <span class="comment">// You can always apply matchers directly; if only a value is provided, it defaults to matches::eq.</span></div>
<div class="line">                and expect::once()                                      <span class="comment">// once() is the default, but you can state that explicitly if desired.</span></div>
<div class="line">                and finally::throws(std::runtime_error{<span class="stringliteral">&quot;some error&quot;</span>});  <span class="comment">// When the expectation matches, it will ultimately throw an exception.</span></div>
<div class="line"> </div>
<div class="line">    REQUIRE_THROWS(mock(<span class="stringliteral">&quot;Test&quot;</span>, 42));                           <span class="comment">// This matches the second expectation and throws the exception as expected.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// There is still a pending expectation for the void() overload.</span></div>
<div class="line">    std::as_const(mock)();                                      <span class="comment">// This explicitly calls the operator() from a const object.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
Mocks as member functions</summary>
<p></p>
<p><code><a class="el" href="d2/d48/classmimicpp_1_1_mock.html" title="A Mock type, which fully supports overload sets.">mimicpp::Mock</a></code> objects can also be used as member functions. However, this approach has its limitations; for example, they cannot be used via a member function pointer.</p>
<div class="fragment"><div class="line"><span class="comment">// Let&#39;s build a function that expects an object and requires a .get() member function.</span></div>
<div class="line"><span class="comment">// This member function should return a value that is printable.</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> foo(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; obj)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; obj.get();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;Mocks can be used as member functions.&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>Mock</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_class" href="d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;int() const&gt; get{}; <span class="comment">// This serves as the .get() member function.</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    Mock mock{};</div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.get.expect_call()</div>
<div class="line">                and finally::returns(42);</div>
<div class="line"> </div>
<div class="line">    foo(mock);                            <span class="comment">// The foo-function then calls the get() member function.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
Mocking interfaces</summary>
<p></p>
<p><code>mimic++</code> also provides utilities for mocking interfaces.</p>
<div class="fragment"><div class="line"><span class="comment">// Let&#39;s say we have the following interface:</span></div>
<div class="line"><span class="keyword">class </span>Interface</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~Interface() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> get() <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// And a function that actually requires an interface this time.</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> foo(<span class="keyword">const</span> Interface&amp; obj)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; obj.get();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;Interfaces can be mocked.&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">class </span>Derived</div>
<div class="line">        : <span class="keyword">public</span> Interface</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        ~Derived() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This generates the override method and a mock object named `get_`.</span></div>
<div class="line">        <a class="code hl_define" href="de/dcd/group___m_o_c_k___i_n_t_e_r_f_a_c_e_s.html#ga6d5cb660367ff702eb85c0257b8d474b">MOCK_METHOD</a>(get, <span class="keywordtype">int</span>, (), <span class="keyword">const</span>);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    Derived mock{};</div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.get_.expect_call()      <span class="comment">// Note the `_` suffix; that&#39;s the name of the mock object.</span></div>
<div class="line">                and finally::returns(42);</div>
<div class="line"> </div>
<div class="line">    foo(mock);        <span class="comment">// `foo` calls the `get()` member function, which forwards the call to the mock object `get_`.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup___m_o_c_k___i_n_t_e_r_f_a_c_e_s_html_ga6d5cb660367ff702eb85c0257b8d474b"><div class="ttname"><a href="de/dcd/group___m_o_c_k___i_n_t_e_r_f_a_c_e_s.html#ga6d5cb660367ff702eb85c0257b8d474b">MOCK_METHOD</a></div><div class="ttdeci">#define MOCK_METHOD</div><div class="ttdoc">Shorthand variant of MIMICPP_MOCK_METHOD.</div><div class="ttdef"><b>Definition</b> InterfaceMock.hpp:539</div></div>
</div><!-- fragment --><p>Sometimes, an interface method may also have several overloads. <code>mimic++</code> directly supports overriding overload-sets.</p>
<div class="fragment"><div class="line"><span class="comment">// Let&#39;s say we have the following interface with an overload set:</span></div>
<div class="line"><span class="keyword">class </span>Interface</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~Interface() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span>&amp; get() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; get() <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// And a function that uses the const overload of that interface.</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> foo(<span class="keyword">const</span> Interface&amp; obj)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; obj.get();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;Interface overload-sets are directly supported.&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">class </span>Derived</div>
<div class="line">        : <span class="keyword">public</span> Interface</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        ~Derived() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This generates two overloads of `get` and a single mock object named `get_`.</span></div>
<div class="line">        <a class="code hl_define" href="de/dcd/group___m_o_c_k___i_n_t_e_r_f_a_c_e_s.html#gafd903cfdd4f9496f29642c9b9e3859c0">MOCK_OVERLOADED_METHOD</a>(</div>
<div class="line">            get,                                    <span class="comment">// The name of the overload set.</span></div>
<div class="line">            <a class="code hl_define" href="de/dcd/group___m_o_c_k___i_n_t_e_r_f_a_c_e_s.html#gaf7eca902448118eaf4359c12be4ed098">ADD_OVERLOAD</a>(<span class="keywordtype">int</span>&amp;, ()),                 <span class="comment">// This enables `int&amp; operator ()()`...</span></div>
<div class="line">            <a class="code hl_define" href="de/dcd/group___m_o_c_k___i_n_t_e_r_f_a_c_e_s.html#gaf7eca902448118eaf4359c12be4ed098">ADD_OVERLOAD</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp;, (), <span class="keyword">const</span>));   <span class="comment">// ... and this the `const int&amp; operator ()() const` on the mock.</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    Derived mock{};</div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> std::as_const(mock).get_.expect_call()   <span class="comment">// Since we expect the const overload to be used, we must explicitly select that overload.</span></div>
<div class="line">                and finally::returns(42);               <span class="comment">// The returned reference is valid as long as the expectation is alive.</span></div>
<div class="line"> </div>
<div class="line">    foo(mock);                      <span class="comment">// `foo` calls the `get() const` member function, which forwards the call to the mock object `get_`, as before.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup___m_o_c_k___i_n_t_e_r_f_a_c_e_s_html_gaf7eca902448118eaf4359c12be4ed098"><div class="ttname"><a href="de/dcd/group___m_o_c_k___i_n_t_e_r_f_a_c_e_s.html#gaf7eca902448118eaf4359c12be4ed098">ADD_OVERLOAD</a></div><div class="ttdeci">#define ADD_OVERLOAD</div><div class="ttdoc">Shorthand variant of MIMICPP_ADD_OVERLOAD.</div><div class="ttdef"><b>Definition</b> InterfaceMock.hpp:551</div></div>
<div class="ttc" id="agroup___m_o_c_k___i_n_t_e_r_f_a_c_e_s_html_gafd903cfdd4f9496f29642c9b9e3859c0"><div class="ttname"><a href="de/dcd/group___m_o_c_k___i_n_t_e_r_f_a_c_e_s.html#gafd903cfdd4f9496f29642c9b9e3859c0">MOCK_OVERLOADED_METHOD</a></div><div class="ttdeci">#define MOCK_OVERLOADED_METHOD</div><div class="ttdoc">Shorthand variant of MIMICPP_MOCK_OVERLOADED_METHOD.</div><div class="ttdef"><b>Definition</b> InterfaceMock.hpp:545</div></div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
Watching object-instances</summary>
<p></p>
<p>The <code><a class="el" href="d3/d5d/classmimicpp_1_1_watched.html" title="CRTP-type, inheriting first from all Watchers and then Base, thus effectively couple them all togethe...">mimicpp::Watched</a></code> helper can report the destruction and relocation of object instances.</p>
<div class="fragment"><div class="line">TEST_CASE(<span class="stringliteral">&quot;LifetimeWatcher and RelocationWatcher can trace the lifetime and relocation of object instances.&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="d3/d5d/classmimicpp_1_1_watched.html">mimicpp::Watched</a>&lt;</div>
<div class="line">        <a class="code hl_class" href="d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;void()&gt;,</div>
<div class="line">        <a class="code hl_class" href="db/d98/classmimicpp_1_1_lifetime_watcher.html">mimicpp::LifetimeWatcher</a>,</div>
<div class="line">        <a class="code hl_class" href="da/d45/classmimicpp_1_1_relocation_watcher.html">mimicpp::RelocationWatcher</a>&gt; watched{};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> watched.expect_destruct();</div>
<div class="line">    <span class="keywordtype">int</span> relocationCounter{};</div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> watched.expect_relocate()</div>
<div class="line">                and then::invoke([&amp;] { ++relocationCounter; })</div>
<div class="line">                and expect::at_least(1);</div>
<div class="line"> </div>
<div class="line">    std::optional wrapped{std::move(watched)};  <span class="comment">// This satisfies one relocate-expectation.</span></div>
<div class="line">    std::optional other{std::move(wrapped)};    <span class="comment">// This satisfies a second relocate-expectation.</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// This doesn&#39;t require a destruct expectation, as moved-from objects are considered dead.</span></div>
<div class="line">    wrapped.reset();</div>
<div class="line">    </div>
<div class="line">    other.reset();                              <span class="comment">// This fulfills the destruct-expectation.</span></div>
<div class="line">    </div>
<div class="line">    REQUIRE(2 == relocationCounter);            <span class="comment">// Let&#39;s see how often the instance has been relocated.</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassmimicpp_1_1_lifetime_watcher_html"><div class="ttname"><a href="db/d98/classmimicpp_1_1_lifetime_watcher.html">mimicpp::LifetimeWatcher</a></div><div class="ttdoc">A watcher type, which reports it&#39;s destructor calls.</div><div class="ttdef"><b>Definition</b> ObjectWatcher.hpp:93</div></div>
<div class="ttc" id="aclassmimicpp_1_1_relocation_watcher_html"><div class="ttname"><a href="da/d45/classmimicpp_1_1_relocation_watcher.html">mimicpp::RelocationWatcher</a></div><div class="ttdoc">A watcher type, which reports it&#39;s move-constructor and -assignment calls.</div><div class="ttdef"><b>Definition</b> ObjectWatcher.hpp:259</div></div>
<div class="ttc" id="aclassmimicpp_1_1_watched_html"><div class="ttname"><a href="d3/d5d/classmimicpp_1_1_watched.html">mimicpp::Watched</a></div><div class="ttdoc">CRTP-type, inheriting first from all Watchers and then Base, thus effectively couple them all togethe...</div><div class="ttdef"><b>Definition</b> ObjectWatcher.hpp:496</div></div>
</div><!-- fragment --><p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md57"></a>
Features &amp; Customizability</h2>
<p>A framework should be a versatile tool that can be utilized in various ways and tailored to meet specific needs. For this reason, <code>mimic++</code> offers a range of customization options. For example, users can create their own expectation policies and integrate them seamlessly without modifying any line of the <code>mimic++</code> codebase.</p>
<h3><a class="anchor" id="autotoc_md58"></a>
Matchers</h3>
<p>Matchers are used to check whether arguments satisfy specific requirements. While there are many existing matchers available, users often have unique needs.</p>
<p><code>mimic++</code> provides a very generic <code><a class="el" href="dc/d5e/classmimicpp_1_1_predicate_matcher.html" title="Generic matcher and the basic building block of most of the built-in matchers.">mimicpp::PredicateMatcher</a></code>, which is often sufficient for most cases. However, if you need full control, you can start with a fresh type (without any inheritance) and build your own. Custom matchers simply need to conform to the <code><a class="el" href="df/d23/conceptmimicpp_1_1matcher__for.html">mimicpp::matcher_for</a></code> concept. For more information, please refer to the documentation.</p>
<h3><a class="anchor" id="autotoc_md59"></a>
Policies</h3>
<p>There are multiple types of policies, depending on the tasks they are designed to fulfill. The <b>expectation policy</b> has full control over whether a match can be made or should be rejected, while the <b>finalize policy</b> determines what a mock should do when it actually matches (such as returning a value or throwing an exception).</p>
<p>These policies can implement arbitrary logic, so feel free to experiment. There is no base type requirement; they simply need to satisfy either the <code><a class="el" href="dd/d1d/conceptmimicpp_1_1expectation__policy__for.html" title="Determines, whether the given type satisfies the requirements of an expectation-policy for the given ...">mimicpp::expectation_policy_for</a></code>, <code><a class="el" href="d4/df8/conceptmimicpp_1_1control__policy.html" title="Determines, whether the given type satisfies the requirements of a control-policy.">mimicpp::control_policy</a></code>, or <code><a class="el" href="d9/d64/conceptmimicpp_1_1finalize__policy__for.html" title="Determines, whether the given type satisfies the requirements of a finalize-policy for the given sign...">mimicpp::finalize_policy_for</a></code>.</p>
<h3><a class="anchor" id="autotoc_md60"></a>
Stringification</h3>
<p><code>mimic++</code> cannot provide stringification for every type, but having a proper textual representation of an object can be very useful when a test fails. <code>mimic++</code> will use <code>std::format</code> (or <a href="https://github.com/fmtlib/fmt">fmt</a>) for types that are formattable, but sometimes that may not meet users' needs, as they might prefer an alternative stringification specifically for testing purposes.</p>
<p>To address this, users can add their own specializations of the <code><a class="el" href="da/d68/classmimicpp_1_1custom_1_1_printer.html" title="User may add specializations, which will then be used during print calls.">mimicpp::custom::Printer</a></code> type, allowing them to specify how a given type should be printed. Custom specializations will always take precedence over any pre-existing printing methods, enabling users to override the stringification of internal report types as well.</p>
<h3><a class="anchor" id="autotoc_md61"></a>
Bring your own string- and char-types</h3>
<p>If you are working with a large framework, there‚Äôs a good chance that it utilizes a custom string or character type ( such as <code>QChar</code> and <code>QString</code> from Qt). While they may appear different, they are essentially just strings, so it would be beneficial to make them fully compatible with the existing string matchers.</p>
<p><code>mimic++</code> supports this; users simply need to provide some trait-specializations. For more information, please refer to the string section of the documentation.</p>
<h3><a class="anchor" id="autotoc_md62"></a>
Call-Conventions</h3>
<p>Call conventions are a somewhat controversial topic, as the C++ language definition does not explicitly address them. However, frameworks like Microsoft's COM utilize the <code>__stdcall</code> call convention, indicating that at least some compilers support these specifications. Consequently, users need the ability to leverage these features.</p>
<p>Since call conventions are not universally portable, <code>mimic++</code> does not define any conventions itself. Instead, it provides an easy macro tool, <code>MIMICPP_REGISTER_CALL_CONVENTION</code>, which users can utilize to make the framework compatible with any call convention they require.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md64"></a>
Integration</h2>
<p><code>mimic++</code> is a header-only library, allowing users to easily access all features by simply including the <code>mimic++/mimic++.hpp</code> header.</p>
<h3><a class="anchor" id="autotoc_md65"></a>
Portability</h3>
<p><code>mimic++</code> is designed to work with any C++20 conforming compiler, independent of the underlying platform or architecture. This is achieved by consistently adhering to the language standards, which is continuously verified through an extensive CI/CD workflow that tracks numerous configurations.</p>
<p>In fact, <code>mimic++</code> is known to work on Windows, Ubuntu, and macOS with both <code>x86_64</code> and <code>x86_32</code> architectures. For a more comprehensive overview, please refer to the Testing section.</p>
<h3><a class="anchor" id="autotoc_md66"></a>
CMake</h3>
<p>The integration into a cmake project is straight-forward.</p>
<div class="fragment"><div class="line">target_link_libraries(</div>
<div class="line">    &lt;your_target_name&gt;</div>
<div class="line">    PUBLIC</div>
<div class="line">    mimicpp::mimicpp</div>
<div class="line">)</div>
</div><!-- fragment --><p>Users can either select a commit in the <b>main</b> branch or a version tag and utilize the CMake <code>FetchContent</code> module:</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(</div>
<div class="line">    mimicpp</div>
<div class="line">        VERSION 5 # or GIT_TAG &lt;commit_hash&gt; </div>
<div class="line">    GIT_REPOSITORY https://github.com/DNKpp/mimicpp</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(mimicpp)</div>
<div class="line"># do not forget linking via target_link_libraries as shown above</div>
</div><!-- fragment --><p>As an alternative, I recommend using <a href="https://github.com/cpm-cmake/CPM.cmake">CPM</a>, which is a convenient wrapper based on the <code>FetchContent</code> feature:</p>
<div class="fragment"><div class="line">include(CPM.cmake) # or include(get_cpm.cmake)</div>
<div class="line"> </div>
<div class="line">CPMAddPackage(&quot;gh:DNKpp/mimicpp@5&quot;) # or gh:DNKpp/mimicpp#&lt;commit_hash&gt;</div>
<div class="line"># do not forget linking via target_link_libraries as shown above</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md67"></a>
Packaging Tools</h3>
<ul>
<li><a href="https://github.com/Microsoft/vcpkg">vcpkg</a> - The Microsoft VC++ Packaging Tool. Thanks to contributions from community members, <code>mimic++</code> also has a <b>vcpkg port</b>, which can be found <a href="https://vcpkg.link/ports/mimicpp">here</a>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md68"></a>
Single-Header</h3>
<p>As an alternative, each release includes a header file named <code>mimic++-amalgamated.hpp</code>, which contains all definitions (except for the specific test framework adapters) and can be easily dropped into any C++20 project. After that, users can simply select the appropriate adapter header from the <code>adapters</code>-folder and include it in their project as well.</p>
<h3><a class="anchor" id="autotoc_md69"></a>
Test Framework</h3>
<p>Mocking frameworks typically do not exist in isolation; rather, they are advanced techniques for creating tests. They should work seamlessly with any existing test framework. Therefore, <code>mimic++</code> provides the <code>IReporter</code> interface, which serves as a bridge from <code>mimic++</code> to the utilized test framework.</p>
<p><code>mimic++</code> already brings some existing reporter implementations for well-known test frameworks, but users can also create custom adapters for any test framework or simply use the default reporter. For more details, please refer to the reporting section in the documentation.</p>
<p>Official adapters exist for the following frameworks:</p>
<ul>
<li><a href="https://github.com/boostorg/test">Boost.Test</a> (tested with v1.88.0)</li>
<li><a href="https://github.com/catchorg">Catch2</a> (tested with v3.7.1)</li>
<li><a href="https://github.com/doctest/doctest">Doctest</a> (tested with v2.4.11)</li>
<li><a href="https://github.com/google/googletest">GTest</a> (tested with v1.15.2)</li>
</ul>
<h3><a class="anchor" id="autotoc_md70"></a>
Documentation</h3>
<p>The documentation is generated using Doxygen. Users can generate it locally by enabling both the <code>MIMICPP_CONFIGURE_DOXYGEN</code> and <code>MIMICPP_ENABLE_GENERATE_DOCS</code> CMake options, and then manually building the target <code>mimicpp-generate-docs</code>.</p>
<p>The documentation for the <b>main</b> branch is always available on GitHub Pages. For the <b>development</b> branch, it is also available on the <b>dev-gh-pages</b> branch, but unfortunately, it is not directly viewable in the browser.</p>
<p>Each release includes the generated documentation as an attachment.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md72"></a>
Testing</h2>
<p><code>mimic++</code> employs a strict testing policy, ensuring that each official feature is thoroughly tested. The results of these test cases are consistently tracked by an extensive CI system, which checks compilation success, test case outcomes, and coverage across dozens of different operating systems, compilers, and build configurations.</p>
<p>For the test builds, the flags <code>-Wall -Wextra -Wpedantic -Werror</code> (or <code>/W4 /WX</code> on MSVC) are set. This ensures that <code>mimic++</code> won't flood your build output with endless warnings - or, even worse, break your builds ‚Äî if you enable these flags in your own projects.</p>
<p>The coverage is generated via <code>gcov</code> and evaluated by <a href="https://app.codacy.com/gh/DNKpp/mimicpp">codacy</a>, <a href="https://codecov.io/gh/DNKpp/mimicpp">codecov</a> and <a href="https://coveralls.io/github/DNKpp/mimicpp">coveralls</a>.</p>
<p>Nevertheless, even with significant effort, achieving 100% code coverage remains out of reach. I strive to cover each branch, but the coverage percentage can vary between different tools. The goal is to get as close to 100% as possible.</p>
<p>On the other hand, there is a significant amount of code that isn't even analyzed by these tools, such as templates and macros. <code>mimic++</code> contains a lot of templated code at its core, which requires at least an equal amount of effort to get right and thoroughly tested. Therefore, it's important to take the coverage percentage with a grain of salt.</p>
<details >
<summary >
CI Tests</summary>
<p></p>
<p>The listed configurations are explicitly tested, but other do probably work, too. As new compilers become available, they will be added to the workflow, but older compilers will probably never be supported.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Symbol   </th><th class="markdownTableHeadCenter">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">works    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">*   </td><td class="markdownTableBodyCenter">works with caveats    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">does not work    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">?   </td><td class="markdownTableBodyCenter">not tested   </td></tr>
</table>
<p><b>Windows</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">OS   </th><th class="markdownTableHeadCenter">Compiler   </th><th class="markdownTableHeadCenter">x86_32   </th><th class="markdownTableHeadCenter">x86_64   </th><th class="markdownTableHeadCenter">c++-20   </th><th class="markdownTableHeadCenter">c++-23   </th><th class="markdownTableHeadCenter">formatting   </th><th class="markdownTableHeadCenter">stacktrace    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Windows 2022   </td><td class="markdownTableBodyCenter">msvc   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">std/fmt   </td><td class="markdownTableBodyCenter">std/cpptrace    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Windows 2022   </td><td class="markdownTableBodyCenter">clangCl   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">std/fmt   </td><td class="markdownTableBodyCenter">std/cpptrace   </td></tr>
</table>
<p><b>Linux</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Compiler   </th><th class="markdownTableHeadCenter">x86_32   </th><th class="markdownTableHeadCenter">x86_64   </th><th class="markdownTableHeadCenter">libstdc++   </th><th class="markdownTableHeadCenter">libc++   </th><th class="markdownTableHeadCenter">c++-20   </th><th class="markdownTableHeadCenter">c++-23   </th><th class="markdownTableHeadCenter">formatting   </th><th class="markdownTableHeadCenter">stacktrace    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">clang-16   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">fmt   </td><td class="markdownTableBodyCenter">cpptrace    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">clang-17   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">std/fmt   </td><td class="markdownTableBodyCenter">std*/cpptrace    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">clang-18   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">*   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">std/fmt   </td><td class="markdownTableBodyCenter">std*/cpptrace    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">clang-19   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">std/fmt   </td><td class="markdownTableBodyCenter">std*/cpptrace    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gcc-12   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">?   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">fmt   </td><td class="markdownTableBodyCenter">cpptrace    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">gcc-13   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">?   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">std/fmt   </td><td class="markdownTableBodyCenter">std*/cpptrace    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gcc-14   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">?   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">std/fmt   </td><td class="markdownTableBodyCenter">std*/cpptrace   </td></tr>
</table>
<p>Note: <code>libc++</code> doesn't support <code>std::stacktrace</code> yet.</p>
<p><b>macOS</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Compiler   </th><th class="markdownTableHeadCenter">x86_64   </th><th class="markdownTableHeadCenter">libstdc++   </th><th class="markdownTableHeadCenter">libc++   </th><th class="markdownTableHeadCenter">c++-20   </th><th class="markdownTableHeadCenter">c++-23   </th><th class="markdownTableHeadCenter">formatting   </th><th class="markdownTableHeadCenter">stacktrace    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">AppleClang-16.0.6   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">?   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">fmt   </td><td class="markdownTableBodyCenter">cpptrace    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">AppleClang-17.0.6   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">?   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">std/fmt   </td><td class="markdownTableBodyCenter">std*/cpptrace    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">AppleClang-18.1.6   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">?   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">std/fmt   </td><td class="markdownTableBodyCenter">std*/cpptrace   </td></tr>
</table>
<p>Note: macOS officially doesn't support 32bit builds, so they are not tested.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md74"></a>
Known Issues</h2>
<h3><a class="anchor" id="autotoc_md75"></a>
Clang-18.1 + libc++</h3>
<p>Date: 25.09.2024</p>
<p>This combination introduced a regression regarding the <code>std::invocable</code> concept and a default parameter of type <code>std::source_location</code>. On this version, all invocable checks will fail, but the <code>std::is_invocable</code> trait still works as expected. Unfortunately this can not solved easily by this framework - sorry for that.</p>
<p>Clang-17 and Clang-19 do not suffer from this issue. For more information have a look <a href="https://github.com/llvm/llvm-project/issues/106428">here</a>.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md77"></a>
Special Acknowledgement</h2>
<p>This framework is heavily inspired by the well-known <a href="https://github.com/rollbear/trompeloeil">trompeloeil</a>, which I have personally used for several years. While it is definitely a solid choice, it can sometimes feel a bit dated, and some macros may not work well with formatting tools and similar utilities. If you need a pre-C++20 mocking framework, I highly recommend giving it a try.</p>
<p>Fun fact: <code>mimic++</code> uses <code>trompeloeil</code> for its own test suite :D </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Apr 25 2025 for mimic++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
